---
import type { CollectionEntry } from 'astro:content';
import type { MarkdownHeading } from 'astro';
import BaseHead from '../components/BaseHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import FormattedDate from '../components/FormattedDate.astro';
import Remark42Comments from '../components/Remark42Comments.astro';
import { extractDescription } from '../utils/extractDescription';
import Prose from '../components/Prose.astro';
import TableOfContents from '../components/TableOfContents.astro';

type EntryData =
	| CollectionEntry<'blog'>['data']
	| CollectionEntry<'monthly'>['data']
	| CollectionEntry<'til'>['data'];

type Props = EntryData & {
	body?: string;
	headings?: MarkdownHeading[];
};

const { title, description: providedDescription, pubDate, updatedDate, socialImage, body, tags, headings = [] } = Astro.props;

const description = providedDescription || (body ? extractDescription(body) : '暂无描述');

// 只有当文章有足够的标题时才显示目录（至少 2 个 h2/h3）
const showToc = headings.filter(h => h.depth >= 2 && h.depth <= 3).length >= 2;
---

<html lang="en">
	<head>
		<BaseHead title={title} description={description} image={socialImage} />
	</head>

	<body>
		<Header />
		<main class="px-4">
			<div
				data-toc-container
				class:list={[
					showToc && "relative mx-auto max-w-[90rem]"
				]}
			>
				<article
					class:list={[
						"mx-auto max-w-3xl space-y-10 text-[var(--color-text-secondary)]"
					]}
				>
						<div data-article-header class="space-y-4 border-b border-border-subtle pb-6 text-center">
						<h1 class="text-3xl font-bold text-[var(--color-text-primary)] sm:text-4xl">{title}</h1>
						<div class="space-y-2 text-sm text-[var(--color-text-muted)]">
							<p>
								<FormattedDate date={pubDate} />
							</p>
							{
								updatedDate && (
									<p>
										Last updated on <FormattedDate date={updatedDate} />
									</p>
								)
							}
						</div>
						{tags && tags.length > 0 && (
							<div class="flex flex-wrap justify-center gap-2">
								{tags.map((tag: string) => (
									<a
										href={`/tags/${tag}`}
										class="inline-flex items-center rounded-full bg-[var(--color-bg-muted)] px-3 py-1 text-xs font-medium text-[var(--color-text-primary)] transition-colors hover:bg-[rgba(var(--color-accent-rgb),0.15)] hover:text-[var(--color-accent)]"
									>
										{tag}
									</a>
								))}
							</div>
						)}
					</div>

					{showToc && (
						<!-- 移动端：浮动按钮 -->
						<button
							data-toc-mobile-toggle
							class="xl:hidden fixed bottom-6 right-6 z-50 flex h-14 w-14 items-center justify-center rounded-full bg-[var(--color-accent)] text-white shadow-lg transition-all duration-300 hover:scale-110 active:scale-95"
							aria-label="打开目录"
						>
							<svg class="h-6 w-6" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
								<path d="M3 4h18M3 12h18M3 20h18" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
							</svg>
						</button>

						<!-- 移动端：抽屉式目录 -->
						<div
							data-toc-mobile-drawer
							class="xl:hidden fixed inset-0 z-50 pointer-events-none"
							aria-hidden="true"
						>
							<!-- 遮罩层 -->
							<div
								data-toc-mobile-overlay
								class="absolute inset-0 bg-black/50 opacity-0 transition-opacity duration-300 pointer-events-none"
							></div>

							<!-- 抽屉内容 -->
							<div
								data-toc-mobile-content
								class="absolute right-0 top-0 h-full w-80 max-w-[85vw] bg-[var(--color-bg-surface)] shadow-2xl translate-x-full transition-transform duration-300 pointer-events-auto"
							>
								<div class="flex h-full flex-col">
									<!-- 头部 -->
									<div class="flex items-center justify-between border-b border-border-subtle px-6 py-4">
										<h2 class="text-lg font-semibold text-[var(--color-text-primary)]">目录</h2>
										<button
											data-toc-mobile-close
											class="flex h-8 w-8 items-center justify-center rounded-full hover:bg-[var(--color-bg-muted)] transition-colors"
											aria-label="关闭目录"
										>
											<svg class="h-5 w-5 text-[var(--color-text-muted)]" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
												<path d="M18 6L6 18M6 6l12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
											</svg>
										</button>
									</div>

									<!-- 目录内容 -->
									<div class="flex-1 overflow-y-auto px-6 py-4">
										<div class="toc-mobile">
											<TableOfContents headings={headings} />
										</div>
									</div>
								</div>
							</div>
						</div>
					)}

					<Prose>
						<slot />
					</Prose>

					<Remark42Comments />
				</article>

				{showToc && (
					<!-- 侧边栏使用 absolute 定位,不影响文章居中布局 -->
					<!-- 高度由 JavaScript 动态设置,匹配文章高度让 sticky 生效 -->
					<aside data-toc-sidebar class="hidden xl:block absolute left-[calc(50%+24rem+3rem)] w-[280px]" style="top: 0;">
						<TableOfContents headings={headings} />
					</aside>
				)}
			</div>
		</main>
		<Footer />
	</body>
	<style>
		/* 移动端抽屉目录样式 */
		.toc-mobile :global(.toc) {
			position: static;
			max-height: none;
			overflow: visible;
			padding: 0;
		}

		.toc-mobile :global(.toc-title) {
			display: none;
		}

		/* 移动端目录链接更大更易点击 */
		.toc-mobile :global(.toc-link) {
			font-size: 0.9375rem;
			padding: 0.375rem 0;
		}

		.toc-mobile :global(.toc-number) {
			font-size: 0.75rem;
		}
	</style>
	<script>
		import mermaid from 'mermaid';
		mermaid.initialize({ startOnLoad: true });

		if (typeof window !== 'undefined') {
			const unwrapCardCells = (table: HTMLTableElement) => {
				const cardCells = table.querySelectorAll('[data-cardified]');

				cardCells.forEach((cell: Element) => {
					const wrapper = cell.querySelector('.table-card-value');
					if (wrapper) {
						while (wrapper.firstChild) {
							cell.insertBefore(wrapper.firstChild, wrapper);
						}
						wrapper.remove();
					}
					cell.removeAttribute('data-cardified');
					cell.removeAttribute('data-label');
				});
			};

			const applyResponsiveTables = () => {
				const tables = document.querySelectorAll<HTMLTableElement>('.prose table');

				tables.forEach((table) => {
					const headers = Array.from(table.querySelectorAll('thead th')).map((th) => {
						return (th.textContent || '').trim();
					});

					const rows = Array.from(table.querySelectorAll('tbody tr'));
					const hasBodyRows = rows.length > 0;
					const columnThreshold = 3;
					const hasWideHeader = headers.length > columnThreshold;
					const hasWideRow = rows.some((row) => {
						return row.querySelectorAll('td, th').length > columnThreshold;
					});
					const shouldCardify =
						headers.length > 0 && hasBodyRows && (hasWideHeader || hasWideRow);

					table.setAttribute('data-card-mode', shouldCardify ? 'cards' : 'table');

					if (!shouldCardify) {
						unwrapCardCells(table);
						return;
					}

					rows.forEach((row) => {
						const cells = Array.from(row.querySelectorAll('td, th'));

						cells.forEach((cell, index) => {
							const label = headers[index] || '';
							if (label.length === 0) {
								cell.removeAttribute('data-label');
								return;
							}
							cell.setAttribute('data-label', label);
							if (!cell.hasAttribute('data-cardified')) {
								const valueWrapper = document.createElement('div');
								valueWrapper.classList.add('table-card-value');
								while (cell.firstChild) {
									valueWrapper.appendChild(cell.firstChild);
								}
								cell.appendChild(valueWrapper);
								cell.setAttribute('data-cardified', 'true');
							}
						});
					});
				});
			};

			const ensureResponsiveTables = () =>
				window.requestAnimationFrame(applyResponsiveTables);

			if (document.readyState === 'loading') {
				document.addEventListener('DOMContentLoaded', ensureResponsiveTables, { once: true });
			} else {
				ensureResponsiveTables();
			}

			window.addEventListener('astro:after-swap', ensureResponsiveTables);
		}

		// Gracefully handle embed iframes that fail to load
		const handleEmbedIframes = () => {
			const iframes = document.querySelectorAll('iframe[data-testid="embed-iframe"]');

			iframes.forEach((iframe) => {
				const iframeElement = iframe as HTMLIFrameElement;

				// Skip if already processed
				if (iframeElement.dataset.embedProcessed === 'true') return;
				iframeElement.dataset.embedProcessed = 'true';

				let hasLoaded = false;
				let timeoutId: number;

				// Wrap in container for smooth transitions
				if (!iframeElement.parentElement?.classList.contains('embed-wrapper')) {
					const wrapper = document.createElement('div');
					wrapper.className = 'embed-wrapper';
					wrapper.style.cssText = 'transition: max-height 0.4s ease, opacity 0.4s ease; overflow: hidden;';
					iframeElement.parentNode?.insertBefore(wrapper, iframeElement);
					wrapper.appendChild(iframeElement);
				}

				const wrapper = iframeElement.parentElement as HTMLElement;

				// Handle successful load
				const handleLoad = () => {
					hasLoaded = true;
					clearTimeout(timeoutId);
					// Ensure wrapper is visible
					wrapper.style.maxHeight = '';
					wrapper.style.opacity = '1';
				};

				iframeElement.addEventListener('load', handleLoad, { once: true });

				// Timeout: collapse if not loaded within 5 seconds
				timeoutId = window.setTimeout(() => {
					if (!hasLoaded) {
						wrapper.style.maxHeight = '0';
						wrapper.style.opacity = '0';
						wrapper.style.marginBottom = '0';
						// Fully hide after animation
						setTimeout(() => {
							wrapper.style.display = 'none';
						}, 400);
					}
				}, 5000);
			});
		};

		// Run on page load
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', handleEmbedIframes, { once: true });
		} else {
			handleEmbedIframes();
		}

		// Re-run on Astro page transitions
		window.addEventListener('astro:after-swap', handleEmbedIframes);

		// Table of Contents - Intersection Observer for active heading
		let currentTocCleanup: (() => void) | null = null;

		const initTocObserver = () => {
			// 清理之前的 observer
			if (currentTocCleanup) {
				currentTocCleanup();
				currentTocCleanup = null;
			}

			const tocLinks = document.querySelectorAll('[data-toc-link]');
			if (tocLinks.length === 0) return;

			const headingElements = Array.from(tocLinks)
				.map((link) => {
					const id = link.getAttribute('data-heading-id');
					return id ? document.getElementById(id) : null;
				})
				.filter((el): el is HTMLElement => el !== null);

			if (headingElements.length === 0) return;

			// 追踪所有当前可见的标题
			const visibleHeadings = new Set<string>();

			const observerOptions = {
				rootMargin: '-100px 0px -66% 0px',
				threshold: [0, 1],
			};

			const setActiveLink = (id: string) => {
				// 移除所有 active 类（包含桌面与移动端两个 TOC）
				tocLinks.forEach((link) => link.classList.remove('active'));

				// 针对同一 heading，给所有匹配链接添加 active
				const matches = document.querySelectorAll(`[data-heading-id="${id}"]`);
				matches.forEach((el) => el.classList.add('active'));
			};

			const updateActiveHeading = () => {
				// 如果没有可见的标题，不做任何事
				if (visibleHeadings.size === 0) return;

				// 找到第一个可见的标题（从上到下）
				let firstVisibleId: string | null = null;
				for (const heading of headingElements) {
					if (visibleHeadings.has(heading.id)) {
						firstVisibleId = heading.id;
						break;
					}
				}

				if (firstVisibleId) {
					setActiveLink(firstVisibleId);
				}
			};

			const observer = new IntersectionObserver((entries) => {
				entries.forEach((entry) => {
					const id = entry.target.id;
					if (entry.isIntersecting) {
						visibleHeadings.add(id);
					} else {
						visibleHeadings.delete(id);
					}
				});

				updateActiveHeading();
			}, observerOptions);

			headingElements.forEach((heading) => observer.observe(heading));

			// 点击处理器映射，用于清理
			const clickHandlers = new Map<Element, () => void>();

			// 添加点击事件处理
			tocLinks.forEach((link) => {
				const handler = () => {
					const id = link.getAttribute('data-heading-id');
					if (id) {
						// 立即更新高亮
						setActiveLink(id);
					}
				};
				clickHandlers.set(link, handler);
				link.addEventListener('click', handler);
			});

			// Cleanup function
			currentTocCleanup = () => {
				observer.disconnect();
				clickHandlers.forEach((handler, link) => {
					link.removeEventListener('click', handler);
				});
				clickHandlers.clear();
			};
		};

		// Initialize on load
		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initTocObserver, { once: true });
		} else {
			initTocObserver();
		}

		// Re-initialize on Astro page transitions
		window.addEventListener('astro:after-swap', initTocObserver);

		// 移动端：抽屉式目录的打开/关闭
		const initMobileTocDrawer = () => {
			const toggleBtn = document.querySelector('[data-toc-mobile-toggle]');
			const drawer = document.querySelector('[data-toc-mobile-drawer]');
			const overlay = document.querySelector('[data-toc-mobile-overlay]');
			const content = document.querySelector('[data-toc-mobile-content]');
			const closeBtn = document.querySelector('[data-toc-mobile-close]');
			const tocLinks = drawer?.querySelectorAll('[data-toc-link]');

			if (!toggleBtn || !drawer || !overlay || !content || !closeBtn) return;

			let isOpen = false;

			const openDrawer = () => {
				isOpen = true;
				drawer.classList.remove('pointer-events-none');
				drawer.setAttribute('aria-hidden', 'false');
				overlay.classList.remove('opacity-0', 'pointer-events-none');
				content.classList.remove('translate-x-full');
				document.body.style.overflow = 'hidden';
			};

			const closeDrawer = () => {
				isOpen = false;
				overlay.classList.add('opacity-0', 'pointer-events-none');
				content.classList.add('translate-x-full');
				document.body.style.overflow = '';
				// 等待动画结束后再隐藏
				setTimeout(() => {
					if (!isOpen) {
						drawer.classList.add('pointer-events-none');
						drawer.setAttribute('aria-hidden', 'true');
					}
				}, 300);
			};

			toggleBtn.addEventListener('click', openDrawer);
			closeBtn.addEventListener('click', closeDrawer);
			overlay.addEventListener('click', closeDrawer);

			// 点击目录链接后自动关闭
			tocLinks?.forEach((link) => {
				link.addEventListener('click', closeDrawer);
			});

			// ESC 键关闭
			document.addEventListener('keydown', (e) => {
				if (e.key === 'Escape' && isOpen) {
					closeDrawer();
				}
			});
		};

		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', initMobileTocDrawer, { once: true });
		} else {
			initMobileTocDrawer();
		}
		window.addEventListener('astro:after-swap', initMobileTocDrawer);

		// 侧边栏定位：让目录从分割线位置开始sticky，并匹配文章高度
		const adjustTocPosition = () => {
			const aside = document.querySelector<HTMLElement>('aside[data-toc-sidebar]');
			const header = document.querySelector<HTMLElement>('[data-article-header]');
			const container = document.querySelector<HTMLElement>('[data-toc-container]');
			if (!aside || !header || !container) return;

			// 获取 header 底部相对于其 offsetParent 的位置
			const headerBottom = header.offsetTop + header.offsetHeight;
			aside.style.top = `${headerBottom}px`;

			// 让 aside 的高度匹配容器的高度减去 top 偏移
			// 这样即使滚动到最底部，sticky 也能一直生效
			const containerHeight = container.offsetHeight;
			const asideHeight = containerHeight - headerBottom;
			aside.style.height = `${asideHeight}px`;
		};

		if (document.readyState === 'loading') {
			document.addEventListener('DOMContentLoaded', adjustTocPosition, { once: true });
		} else {
			adjustTocPosition();
		}
		window.addEventListener('resize', adjustTocPosition);
		window.addEventListener('astro:after-swap', adjustTocPosition);
	</script>
</html>
